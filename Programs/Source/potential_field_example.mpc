# potential_field_astar.mpc
from oram import OptimalORAM
from Compiler.astar import astar, simple_manhattan_heuristic_factory
from Compiler.types import sint, regint, MemValue, Array
from Compiler.util import log2
from Compiler.library import for_range

# 8x8 grid parameters
GRID_WIDTH = 8
GRID_HEIGHT = 8
TOTAL_NODES = GRID_WIDTH * GRID_HEIGHT
MAX_EDGES = TOTAL_NODES * 5

# Obstacles - physical barriers
obstacles = {9, 10, 11, 17, 25, 33}

# Fire repulsion zones - now forcing the path to pass through some low-risk areas
fire_repulsion_zones = {
    # Basic risk areas - all nodes have basic risk
    0: 1, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 1, 7: 1,
    8: 1, 12: 1, 13: 1, 14: 1, 15: 1,
    16: 1, 20: 1, 21: 1, 22: 1, 23: 1,
    24: 1, 28: 1, 29: 1, 30: 1, 31: 1,
    32: 1, 36: 1, 37: 1, 38: 1, 39: 1,
    40: 1, 44: 1, 45: 1, 46: 1, 47: 1,
    48: 1, 52: 1, 53: 1, 54: 1, 55: 1,
    56: 1, 57: 1, 58: 1, 59: 1, 60: 1, 61: 1, 62: 1, 63: 1,

    # High-risk areas
    18: 10, 19: 10, 26: 8, 27: 9, 34: 6, 35: 7,

    # Medium risk on key paths - forcing algorithm to make trade-offs
    20: 4, 21: 3, 28: 5, 29: 4, 36: 3, 37: 2
}

start_node = 0
goal_node = 63

print_ln('=== POTENTIAL FIELD A* SEARCH ===')
print_ln('GRID_INFO: %s %s', GRID_WIDTH, GRID_HEIGHT)
print_ln('START_NODE: %s', start_node)
print_ln('GOAL_NODE: %s', goal_node)
print_ln('OBSTACLES: 9 10 11 17 25 33')

# Print fire zone information
fire_zones_str = ' '.join([f'{k}:{v}' for k, v in fire_repulsion_zones.items()])
print_ln('FIRE_REPULSION_ZONES: %s', fire_zones_str)

# Create graph structure
edges = OptimalORAM(MAX_EDGES, entry_size=(log2(TOTAL_NODES), 8, 1))
e_index = OptimalORAM(TOTAL_NODES, entry_size=log2(MAX_EDGES))

def calculate_potential_field_cost(current_node, neighbor_node):
    """
    Calculate potential field cost: base_cost + fire_repulsion
    """
    base_cost = 1  # Basic movement cost

    # Get fire level of neighbor node
    fire_repulsion = 0
    if neighbor_node in fire_repulsion_zones:
        fire_repulsion = fire_repulsion_zones[neighbor_node]

    # Total cost = base cost + fire repulsion
    total_cost = base_cost + fire_repulsion

    return total_cost

# Build potential field enhanced graph
edge_list = []
edge_starts = [0] * TOTAL_NODES
current_edge_index = 0

print_ln('BUILDING_POTENTIAL_FIELD_GRAPH')
for node in range(TOTAL_NODES):
    edge_starts[node] = current_edge_index

    if node in obstacles:
        # Physical obstacles - no outgoing edges
        pass
    else:
        x = node % GRID_WIDTH
        y = node // GRID_WIDTH

        # Four movement directions
        directions = [(0, -1), (-1, 0), (1, 0), (0, 1)]
        valid_neighbors = []

        for dx, dy in directions:
            nx = x + dx
            ny = y + dy

            if 0 <= nx < GRID_WIDTH and 0 <= ny < GRID_HEIGHT:
                neighbor = ny * GRID_WIDTH + nx
                if neighbor not in obstacles:
                    valid_neighbors.append(neighbor)

        # Calculate potential field cost for each neighbor
        for i, neighbor in enumerate(valid_neighbors):
            is_last = 1 if i == len(valid_neighbors) - 1 else 0

            # Use potential field cost function
            potential_cost = calculate_potential_field_cost(node, neighbor)
            edge_list.append((neighbor, potential_cost, is_last))
            current_edge_index += 1

# Fill graph data
for i, edge in enumerate(edge_list):
    edges[i] = edge

for node in range(TOTAL_NODES):
    e_index[node] = edge_starts[node]

print_ln('TOTAL_EDGES: %s', len(edge_list))
print_ln('POTENTIAL_FIELD_GRAPH_BUILT')

# Run potential field enhanced A* search
print_ln('STARTING_POTENTIAL_FIELD_ASTAR')

# Goal attraction heuristic function
goal_attraction_heuristic = simple_manhattan_heuristic_factory(sint(goal_node), GRID_WIDTH)

dist, found = astar(sint(start_node), sint(goal_node), edges, e_index,
                    goal_attraction_heuristic, OptimalORAM, n_loops=200)

# Output results
print_ln('POTENTIAL_FIELD_SEARCH_COMPLETE')
found_value = found.reveal()
print_ln('PATH_FOUND: %s', found_value)

print_ln('POTENTIAL_FIELD_NODE_DATA:')
for i in range(TOTAL_NODES):
    cost, prev = dist[i]
    cost_val = cost.reveal()
    prev_val = prev.reveal()
    print_ln('NODE_POTENTIAL: %s %s %s', i, cost_val, prev_val)

print_ln('END_POTENTIAL_FIELD_SEARCH')